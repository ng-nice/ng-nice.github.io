{
  "id": "guide/aot-compiler",
  "title": "The Ahead-of-Time (AOT) Compiler",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"the-ahead-of-time-aot-compiler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#the-ahead-of-time-aot-compiler\"><i class=\"material-icons\">link</i></a>The Ahead-of-Time (AOT) Compiler</h1>\n<p translation-origin=\"off\">The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code.</p>\n<p translation-result=\"\">Angular 的“预先（AOT）编译器”会在构建期间把 Angular 应用的 HTML 和 TypeScript 代码编译成高效的 JavaScript 代码，之后浏览器就可以下载并快速运行这些代码。</p>\n<p translation-origin=\"off\">This guide explains how to build with the AOT compiler using different compiler options and how to write Angular metadata that AOT can compile.</p>\n<p translation-result=\"\">本章描述了如何使用 AOT 编译器，以及如何书写能被 AOT 编译的 Angular 元数据。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">  <a href=\"https://www.youtube.com/watch?v=kW9cJsvcsGo\">Watch compiler author Tobias Bosch explain the Angular Compiler</a> at AngularConnect 2016.</p>\n<p translation-result=\"\">  观看编译器作者Tobias Bosch在AngularConnect 2016大会里，对<a href=\"http://v.youku.com/v_show/id_XMTc1NTE4NTkwOA==.html?from=y1.7-1.4\" target=\"_blank\">Angular编译器</a>的演讲。</p>\n</div>\n<a id=\"overview\"></a>\n<h2 translation-origin=\"off\" id=\"angular-compilation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-compilation\"><i class=\"material-icons\">link</i></a>Angular compilation</h2>\n<h2 translation-result=\"\" id=\"angular-compilation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-compilation\"><i class=\"material-icons\">link</i></a>Angular 中的编译</h2>\n<p translation-origin=\"off\">An Angular application consists largely of components and their HTML templates.\nBefore the browser can render the application,\nthe components and templates must be converted to executable JavaScript by an <em>Angular compiler</em>.</p>\n<p translation-origin=\"off\">Angular offers two ways to compile your application:</p>\n<ol>\n<li>\n<p translation-origin=\"off\"><strong><em>Just-in-Time</em> (JIT)</strong>, which compiles your app in the browser at runtime</p>\n</li>\n<li>\n<p translation-origin=\"off\"><strong><em>Ahead-of-Time</em> (AOT)</strong>, which compiles your app at build time.</p>\n</li>\n</ol>\n<p translation-origin=\"off\">JIT compilation is the default when you run the <em>build-only</em> or the <em>build-and-serve-locally</em> CLI commands:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n\n  ng build\n  ng serve\n\n</code-example>\n<a id=\"compile\"></a>\n<p translation-origin=\"off\">For AOT compilation, append the <code>--aot</code> flags to the <em>build-only</em> or the <em>build-and-serve-locally</em> CLI commands:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n\n  ng build --aot\n  ng serve --aot\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The <code>--prod</code> meta-flag compiles with AOT by default.</p>\n<p translation-origin=\"off\">See the <a href=\"https://github.com/angular/angular-cli/wiki\">CLI documentation</a> for details, especially the <a href=\"https://github.com/angular/angular-cli/wiki/build\"><code>build</code> topic</a>.</p>\n<p translation-result=\"\">要了解更多，请参见<a href=\"https://github.com/angular/angular-cli/wiki\">CLI 文档</a>，特别是<a href=\"https://github.com/angular/angular-cli/wiki/build\"><code>build</code> 这个主题</a>。</p>\n</div>\n<a id=\"why-aot\"></a>\n<h2 translation-origin=\"off\" id=\"why-compile-with-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#why-compile-with-aot\"><i class=\"material-icons\">link</i></a>Why compile with AOT?</h2>\n<h2 translation-result=\"\" id=\"why-compile-with-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#why-compile-with-aot\"><i class=\"material-icons\">link</i></a>为什么需要AOT编译？</h2>\n<p translation-origin=\"off\"><em>Faster rendering</em></p>\n<p translation-result=\"\"><strong>渲染得更快</strong></p>\n<p translation-origin=\"off\">With AOT, the browser downloads a pre-compiled version of the application.\nThe browser loads executable code so it can render the application immediately, without waiting to compile the app first.</p>\n<p translation-result=\"\">使用AOT，浏览器下载预编译版本的应用程序。\n浏览器直接加载运行代码，所以它可以立即渲染该应用，而不用等应用完成首次编译。</p>\n<p translation-origin=\"off\"><em>Fewer asynchronous requests</em></p>\n<p translation-result=\"\"><strong>需要的异步请求更少</strong></p>\n<p translation-origin=\"off\">The compiler <em>inlines</em> external HTML templates and CSS style sheets within the application JavaScript,\neliminating separate ajax requests for those source files.</p>\n<p translation-result=\"\">编译器把外部HTML模板和CSS样式表内联到了该应用的JavaScript中。\n消除了用来下载那些源文件的Ajax请求。</p>\n<p translation-origin=\"off\"><em>Smaller Angular framework download size</em></p>\n<p translation-result=\"\"><strong>需要下载的Angular框架体积更小</strong></p>\n<p translation-origin=\"off\">There's no need to download the Angular compiler if the app is already compiled.\nThe compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.</p>\n<p translation-result=\"\">如果应用已经编译过了，自然不需要再下载Angular编译器了。\n该编译器差不多占了Angular自身体积的一半儿，所以，省略它可以显著减小应用的体积。</p>\n<p translation-origin=\"off\"><em>Detect template errors earlier</em></p>\n<p translation-result=\"\"><strong>提早检测模板错误</strong></p>\n<p translation-origin=\"off\">The AOT compiler detects and reports template binding errors during the build step\nbefore users can see them.</p>\n<p translation-result=\"\">AOT编译器在构建过程中检测和报告模板绑定错误，避免用户遇到这些错误。</p>\n<p translation-origin=\"off\"><em>Better security</em></p>\n<p translation-result=\"\"><strong>更安全</strong></p>\n<p translation-origin=\"off\">AOT compiles HTML templates and components into JavaScript files long before they are served to the client.\nWith no templates to read and no risky client-side HTML or JavaScript evaluation,\nthere are fewer opportunities for injection attacks.</p>\n<p translation-result=\"\">AOT编译远在HTML模版和组件被服务到客户端之前，将它们编译到JavaScript文件。\n没有模版可以阅读，没有高风险客户端HTML或JavaScript可利用，所以注入攻击的机会较少。</p>\n<a id=\"compiler-options\"></a>\n<h2 translation-origin=\"off\" id=\"angular-compiler-options\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-compiler-options\"><i class=\"material-icons\">link</i></a>Angular Compiler Options</h2>\n<p translation-origin=\"off\">You can control your app compilation by providing template compiler options in the <code>tsconfig.json</code> file along with the options supplied to the TypeScript compiler. The template compiler options are specified as members of\n<code>\"angularCompilerOptions\"</code> object as shown below:</p>\n<code-example language=\"json\">\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    ...\n  },\n  \"angularCompilerOptions\": {\n    \"fullTemplateTypeCheck\": true,\n    \"preserveWhitespaces\": true,\n    ...\n  }\n}\n</code-example>\n<h3 translation-origin=\"off\" id=\"skipmetadataemit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skipmetadataemit\"><i class=\"material-icons\">link</i></a><em>skipMetadataEmit</em></h3>\n<p translation-origin=\"off\">This option tells the compiler not to produce <code>.metadata.json</code> files.\nThe option is <code>false</code> by default.</p>\n<p translation-origin=\"off\"><code>.metadata.json</code> files contain infomration needed by the template compiler from a <code>.ts</code>\nfile that is not included in the <code>.d.ts</code> file produced by the TypeScript compiler. This information contains,\nfor example, the content of annotations (such as a component's template) which TypeScript\nemits to the <code>.js</code> file but not to the <code>.d.ts</code> file.</p>\n<p translation-origin=\"off\">This option should be set to <code>true</code> if using TypeScript's <code>--outFile</code> option, as the metadata files\nare not valid for this style of TypeScript output. It is not recommeded to use <code>--outFile</code> with\nAngular. Use a bundler, such as <a href=\"https://webpack.js.org/\">webpack</a>, instead.</p>\n<p translation-origin=\"off\">This option can also be set to <code>true</code> when using factory summaries as the factory summaries\ninclude a copy of the information that is in the <code>.metadata.json</code> file.</p>\n<h3 translation-origin=\"off\" id=\"strictmetadataemit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictmetadataemit\"><i class=\"material-icons\">link</i></a><em>strictMetadataEmit</em></h3>\n<p translation-origin=\"off\">This option tells the template compiler to report an error to the <code>.metadata.json</code>\nfile if <code>\"skipMetadataEmit\"</code> is <code>false</code> . This option is <code>false</code> by default. This should only be used when <code>\"skipMetadataEmit\"</code> is <code>false</code> and <code>\"skipTemplateCodeGen\"</code> is <code>true</code>.</p>\n<p translation-origin=\"off\">It is intended to validate the <code>.metadata.json</code> files emitted for bundling with an <code>npm</code> package. The validation is overly strict and can emit errors for metadata that would never produce an error when used by the template compiler. You can choose to suppress the error emitted by this option for an exported symbol by including <code>@dynamic</code> in the comment documenting the symbol.</p>\n<p translation-origin=\"off\">It is valid for <code>.metadata.json</code> files to contain errors. The template compiler reports these errors\nif the metadata is used to determine the contents of an annotation. The metadata\ncollector cannot predict the symbols that are designed to use in an annotation, so it will preemptively\ninclude error nodes in the metadata for the exported symbols. The template compiler can then use the error\nnodes to report an error if these symbols are used. If the client of a library intends to use a symbol in an annotation, the template compiler will not normally report\nthis until the client uses the symbol. This option allows detecting these errors during the build phase of\nthe library and is used, for example, in producing Angular libraries themselves.</p>\n<h3 translation-origin=\"off\" id=\"skiptemplatecodegen\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skiptemplatecodegen\"><i class=\"material-icons\">link</i></a><em>skipTemplateCodegen</em></h3>\n<p translation-origin=\"off\">This option tells the compiler to suppress emitting <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files. When set,\nthis turns off most of the template compiler and disables reporting template diagnostics.\nThis option can be used to instruct the\ntemplate compiler to produce <code>.metadata.json</code> files for distribution with an <code>npm</code> package while\navoiding the production of <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files that cannot be distributed to\n<code>npm</code>.</p>\n<h3 translation-origin=\"off\" id=\"strictinjectionparameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictinjectionparameters\"><i class=\"material-icons\">link</i></a><em>strictInjectionParameters</em></h3>\n<p translation-origin=\"off\">When set to <code>true</code>, this options tells the compiler to report an error for a parameter supplied\nwhose injection type cannot be determined. When this value option is not provided or is <code>false</code>, constructor parameters of classes marked with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> whose type cannot be resolved will\nproduce a warning.</p>\n<p translation-origin=\"off\"><em>Note</em>: It is recommended to change this option explicitly to <code>true</code> as this option will default to <code>true</code> in the future.</p>\n<h3 translation-origin=\"off\" id=\"flatmoduleoutfile\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleoutfile\"><i class=\"material-icons\">link</i></a><em>flatModuleOutFile</em></h3>\n<p translation-origin=\"off\">When set to <code>true</code>, this option tells the template compiler to generate a flat module\nindex of the given file name and the corresponding flat module metadata. Use this option when creating\nflat modules that are packaged similarly to <code>@angular/core</code> and <code>@angular/common</code>. When this option\nis used, the <code>package.json</code> for the library should refer\nto the generated flat module index instead of the library index file. With this\noption only one <code>.metadata.json</code> file is produced that contains all the metadata necessary\nfor symbols exported from the library index. In the generated <code>.ngfactory.js</code> files, the flat\nmodule index is used to import symbols that includes both the public API from the library index\nas well as shrowded internal symbols.</p>\n<p translation-origin=\"off\">By default the <code>.ts</code> file supplied in the <code>files</code> field is assumed to be library index.\nIf more than one <code>.ts</code> file is specified, <code>libraryIndex</code> is used to select the file to use.\nIf more than one <code>.ts</code> file is supplied without a <code>libraryIndex</code>, an error is produced. A flat module\nindex <code>.d.ts</code> and <code>.js</code> will be created with the given <code>flatModuleOutFile</code> name in the same\nlocation as the library index <code>.d.ts</code> file. For example, if a library uses\n<code>public_api.ts</code> file as the library index of the module, the <code>tsconfig.json</code> <code>files</code> field\nwould be <code>[\"public_api.ts\"]</code>. The <code>flatModuleOutFile</code> options could then be set to, for\nexample <code>\"index.js\"</code>, which produces <code>index.d.ts</code> and  <code>index.metadata.json</code> files. The\nlibrary's <code>package.json</code>'s <code>module</code> field would be <code>\"index.js\"</code> and the <code>typings</code> field\nwould be <code>\"index.d.ts\"</code>.</p>\n<h3 translation-origin=\"off\" id=\"flatmoduleid\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleid\"><i class=\"material-icons\">link</i></a><em>flatModuleId</em></h3>\n<p translation-origin=\"off\">This option specifies the preferred module id to use for importing a flat module.\nReferences generated by the template compiler will use this module name when importing symbols\nfrom the flat module.\nThis is only meaningful when <code>flatModuleOutFile</code> is also supplied. Otherwise the compiler ignores\nthis option.</p>\n<h3 translation-origin=\"off\" id=\"generatecodeforlibraries\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#generatecodeforlibraries\"><i class=\"material-icons\">link</i></a><em>generateCodeForLibraries</em></h3>\n<p translation-origin=\"off\">This option tells the template compiler to generate factory files (<code>.ngfactory.js</code> and <code>.ngstyle.js</code>)\nfor <code>.d.ts</code> files with a corresponding <code>.metadata.json</code> file. This option defaults to\n<code>true</code>. When this option is <code>false</code>, factory files are generated only for <code>.ts</code> files.</p>\n<p translation-origin=\"off\">This option should be set to <code>false</code> when using factory summaries.</p>\n<h3 translation-origin=\"off\" id=\"fulltemplatetypecheck\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#fulltemplatetypecheck\"><i class=\"material-icons\">link</i></a><em>fullTemplateTypeCheck</em></h3>\n<p translation-origin=\"off\">This option tells the compiler to enable the <a href=\"guide/aot-compiler#binding-expresion-validation\">binding expression validation</a>\nphase of the template compiler which uses TypeScript to validate binding expressions.</p>\n<p translation-origin=\"off\">This option is <code>false</code> by default.</p>\n<p translation-origin=\"off\"><em>Note</em>: It is recommended to set this to <code>true</code> as this option will default to <code>true</code> in the future.</p>\n<h3 translation-origin=\"off\" id=\"annotateforclosurecompiler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotateforclosurecompiler\"><i class=\"material-icons\">link</i></a><em>annotateForClosureCompiler</em></h3>\n<p translation-origin=\"off\">This option tells the compiler to use <a href=\"https://github.com/angular/tsickle\">Tsickle</a> to annotate the emitted\nJavaScript with <a href=\"http://usejsdoc.org/\">JsDoc</a> comments needed by the\n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a>. This option defaults to <code>false</code>.</p>\n<h3 translation-origin=\"off\" id=\"annotationsas\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotationsas\"><i class=\"material-icons\">link</i></a><em>annotationsAs</em></h3>\n<p translation-origin=\"off\">Use this option to modify how the Angular specific annotations are emitted to improve tree-shaking. Non-Angular\nannotations and decorators are unnaffected. Default is <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code>.</p>\n<table>\n<thead>\n<tr>\n<th>value</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>decorators</code></td>\n<td>Leave the Decorators in-place. This makes compilation faster. TypeScript will emit calls to the __decorate helper.  Use \n<code>--emitDecoratorMetadata</code>\n for runtime reflection.  However, the resulting code will not properly tree-shake.</td>\n</tr>\n<tr>\n<td><code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code></td>\n<td>Replace decorators with a static field in the class. Allows advanced tree-shakers like \n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a>\n to remove unused classes.</td>\n</tr>\n</tbody>\n</table>\n<h3 translation-origin=\"off\" id=\"trace\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#trace\"><i class=\"material-icons\">link</i></a><em>trace</em></h3>\n<p translation-origin=\"off\">This tells the compiler to print extra information while compiling templates.</p>\n<h3 translation-origin=\"off\" id=\"enablelegacytemplate\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#enablelegacytemplate\"><i class=\"material-icons\">link</i></a><em>enableLegacyTemplate</em></h3>\n<p translation-origin=\"off\">The use of <code>&#x3C;template></code> element was deprecated starting in Angular 4.0 in favor of using\n<code>&#x3C;ng-template></code> to avoid colliding with the DOM's element of the same name. Setting this option to\n<code>true</code> enables the use of the deprecated <code>&#x3C;template></code> element . This option\nis <code>false</code> by default. This option might be required by some third-party Angular libraries.</p>\n<h3 translation-origin=\"off\" id=\"disableexpressionlowering\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disableexpressionlowering\"><i class=\"material-icons\">link</i></a><em>disableExpressionLowering</em></h3>\n<p translation-origin=\"off\">The Angular template compiler transforms code that is used, or could be used, in an annotation\nto allow it to be imported from template factory modules. See\n<a href=\"guide/aot-compiler#metadata-rewriting\">metadata rewriting</a> for more information.</p>\n<p translation-origin=\"off\">Setting this option to <code>false</code> disables this rewriting, requiring the rewriting to be\ndone manually.</p>\n<h3 translation-origin=\"off\" id=\"preservewhitespaces\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#preservewhitespaces\"><i class=\"material-icons\">link</i></a><em>preserveWhitespaces</em></h3>\n<p translation-origin=\"off\">This option tells the compiler whether to remove blank text nodes from compiled templates.\nAs of v6, this option is <code>false</code> by default, which results in smaller emitted template factory modules.</p>\n<h3 translation-origin=\"off\" id=\"allowemptycodegenfiles\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#allowemptycodegenfiles\"><i class=\"material-icons\">link</i></a><em>allowEmptyCodegenFiles</em></h3>\n<p translation-origin=\"off\">Tells the compiler to generate all the possible generated files even if they are empty. This option is\n<code>false</code> by default. This is an option used by <code>bazel</code> build rules and is needed to simplify\nhow <code>bazel</code> rules track file dependencies. It is not recommended to use this option outside of the <code>bazel</code>\nrules.</p>\n<h3 translation-origin=\"off\" id=\"enableivy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#enableivy\"><i class=\"material-icons\">link</i></a><em>enableIvy</em></h3>\n<p translation-origin=\"off\">  Tells the compiler to generate definitions using the Render3 style code generation. This option defaults to <code>false</code>.</p>\n<p translation-origin=\"off\">  Not all features are supported with this option enabled. It is only supported\nfor experimentation and testing of Render3 style code generation.</p>\n<p translation-origin=\"off\">  <em>Note</em>: Is it not recommended to use this option as it is not yet feature complete with the Render2 code generation.</p>\n<h2 translation-origin=\"off\" id=\"angular-metadata-and-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-metadata-and-aot\"><i class=\"material-icons\">link</i></a>Angular Metadata and AOT</h2>\n<h2 translation-result=\"\" id=\"angular-metadata-and-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-metadata-and-aot\"><i class=\"material-icons\">link</i></a>Angular 元数据与 AOT</h2>\n<p translation-origin=\"off\">The Angular <strong>AOT compiler</strong> extracts and interprets <strong>metadata</strong> about the parts of the application that Angular is supposed to manage.</p>\n<p translation-result=\"\">Angular 的 <strong>AOT 编译器</strong>会提取并解释应用中由 Angular 管理的各个部件的<strong>元数据</strong>。</p>\n<p translation-origin=\"off\">Angular metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n<p translation-result=\"\">Angular 的元数据会告诉 Angular 如何创建应用中类的实例以及如何在运行期间与它们交互。</p>\n<p translation-origin=\"off\">You specify the metadata with <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>.\nYou also specify metadata implicitly in the constructor declarations of these decorated classes.</p>\n<p translation-result=\"\">我们通过<strong>装饰器</strong>来指定元数据，比如 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 和 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>。\n我们还可以在这些带装饰器的类的构造函数中隐式指定元数据。</p>\n<p translation-origin=\"off\">In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n<p translation-result=\"\">在下列范例中，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据对象和类的构造函数会告诉 Angular 如何创建和显示 <code>TypicalComponent</code> 的实例。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<p translation-origin=\"off\">The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n<p translation-result=\"\">Angular 编译器只提取<strong>一次</strong>元数据，并且为 <code>TypicalComponent</code> 生成一个<strong>工厂</strong>。\n当它需要创建 <code>TypicalComponent</code> 的实例时，Angular 调用这个工厂，工厂会生成一个新的可视元素，并且把它（及其依赖）绑定到组件类的一个新实例上。</p>\n<h2 translation-origin=\"off\" id=\"metadata-restrictions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a>Metadata restrictions</h2>\n<h2 translation-result=\"\" id=\"metadata-restrictions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a>元数据的限制</h2>\n<p translation-origin=\"off\">You write metadata in a <em>subset</em> of TypeScript that must conform to the following general constraints:</p>\n<p translation-result=\"\">我们只能使用 TypeScript 的一个<strong>子集</strong>书写元数据，它必须满足下列限制：</p>\n<ol>\n<li>\n<p translation-origin=\"off\">Limit <a href=\"guide/aot-compiler#expression-syntax\">expression syntax</a> to the supported subset of JavaScript.</p>\n<p translation-result=\"\"><a href=\"guide/aot-compiler#expression-syntax\">表达式语法</a>只支持 JavaScript 的一个有限的子集。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Only reference exported symbols after <a href=\"guide/aot-compiler#folding\">code folding</a>.</p>\n<p translation-result=\"\">只能引用<a href=\"guide/aot-compiler#folding\">代码收缩</a>后导出的符号。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Only call <a href=\"guide/aot-compiler#supported-functions\">functions supported</a> by the compiler.</p>\n<p translation-result=\"\">只能调用编译器<a href=\"guide/aot-compiler#supported-functions\">支持的那些函数</a>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Decorated and data-bound class members must be public.</p>\n<p translation-result=\"\">被装饰和用于数据绑定的类成员必须是公共（public）的。</p>\n</li>\n</ol>\n<p translation-origin=\"off\">The next sections elaborate on these points.</p>\n<p translation-result=\"\">我们将在下一节详细解释这些问题。</p>\n<h2 translation-origin=\"off\" id=\"how-aot-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a>How AOT works</h2>\n<h2 translation-result=\"\" id=\"how-aot-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a>AOT 工作原理</h2>\n<p translation-origin=\"off\">It helps to think of the AOT compiler as having two phases: a code analysis phase in which it simply records a representation of the source; and a code generation phase in which the compiler's <code>StaticReflector</code> handles the interpretation as well as places restrictions on what it interprets.</p>\n<p translation-result=\"\">我们可以把 AOT 编译器看做两个阶段：在代码分析阶段，它只记录源代码，而在代码生成阶段，编译器的<code>StaticReflector</code>会解释这些结果，并为这些结果加上限制。</p>\n<h2 translation-origin=\"off\" id=\"phase-1-analysis\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-analysis\"><i class=\"material-icons\">link</i></a>Phase 1: analysis</h2>\n<h2 translation-result=\"\" id=\"phase-1-analysis\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-analysis\"><i class=\"material-icons\">link</i></a>阶段1：分析</h2>\n<p translation-origin=\"off\">The TypeScript compiler does some of the analytic work of the first phase. It emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.</p>\n<p translation-result=\"\">TypeScript 编译器会做一些初步的分析工作，它会生成<strong>类型定义文件</strong><code>.d.ts</code>，其中带有类型信息，Angular 编译器需要借助它们来生成代码。</p>\n<p translation-origin=\"off\">At the same time, the AOT <strong><em>collector</em></strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.json</code></strong> files, one per <code>.d.ts</code> file.</p>\n<p translation-result=\"\">同时，AOT <strong>收集器（collector）</strong> 会记录 Angular 装饰器中的元数据，并把它们输出到<strong><code>.metadata.json</code></strong>文件中，和每个<code>.d.ts</code>文件相对应。</p>\n<p translation-origin=\"off\">You can think of <code>.metadata.json</code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n<p translation-result=\"\">我们可以把<code>.metadata.json</code>文件看做一个包括全部装饰器的元数据的全景图，就像<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">抽象语法树 (AST) </a>一样。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Angular's <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a>\ndescribes the JSON format as a collection of TypeScript interfaces.</p>\n<p translation-result=\"\">Angular 的 <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 把这个 JSON 格式表示成了一组 TypeScript 接口。</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<h3 translation-origin=\"off\" id=\"expression-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax\"><i class=\"material-icons\">link</i></a>Expression syntax</h3>\n<p translation-origin=\"off\">The <em>collector</em> only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n<p translation-result=\"\">这个<strong>收集器</strong>只能理解 JavaScript 的一个子集。\n请使用下列受限语法定义元数据对象：</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td><code>['apples', 'flour', ...the_rest]</code></td>\n</tr>\n<tr>\n<td>Calls</td>\n<td><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td>New</td>\n<td><code>new Oven()</code></td>\n</tr>\n<tr>\n<td>Property access</td>\n<td><code>pie.slice</code></td>\n</tr>\n<tr>\n<td>Array index</td>\n<td><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td>A template string</td>\n<td><code>\n`\npie is ${multiplier} times better than cake\n`\n</code></td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td><code>'pi'</code></td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td><code>3.14153265</code></td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td><code>null</code></td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td><code>!cake</code></td>\n</tr>\n<tr>\n<td>Supported Binary operator</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b</code></td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ? b : c</code></td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td><code>(<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b)</code></td>\n</tr>\n</tbody>\n</table>\n<p translation-origin=\"off\">If an expression uses unsupported syntax, the <em>collector</em> writes an error node to the <code>.metadata.json</code> file. The compiler later reports the error if it needs that\npiece of metadata to generate the application code.</p>\n<p translation-result=\"\">如果表达式使用了不支持的语法，<strong>收集器</strong>就会往<code>.metadata.json</code>文件中写入一个错误节点。稍后，如果编译器用到元数据中的这部分内容来生成应用代码，它就会报告这个错误。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\"> If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.json</code> file with errors, set the <code>strictMetadataEmit</code> option in <code>tsconfig</code>.</p>\n<p translation-result=\"\"> 如果你希望<code>ngc</code>立即汇报这些语法错误，而不要生成带有错误信息的<code>.metadata.json</code>文件，可以到<code>tsconfig</code>中设置 <code>strictMetadataEmit</code> 选项。</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<p translation-origin=\"off\">Angular libraries have this option to ensure that all Angular <code>.metadata.json</code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n<p translation-result=\"\">Angular 库通过这个选项来确保所有的 <code>.metadata.json</code> 文件都是干净的。当你要构建自己的代码库时，这也同样是一项最佳实践。</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<h3 translation-origin=\"off\" id=\"no-arrow-functions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a>No arrow functions</h3>\n<p translation-origin=\"off\">The AOT compiler does not support <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n<p translation-origin=\"off\">Consider the following component decorator:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n</code-example>\n<p translation-origin=\"off\">The AOT <em>collector</em> does not support the arrow function, <code>() => new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.</p>\n<p translation-origin=\"off\">When the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n<p translation-origin=\"off\">You can fix the error by converting to this:</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<p translation-origin=\"off\">Beginning in version 5, the compiler automatically performs this rewritting while emitting the <code>.js</code> file.</p>\n<a id=\"function-calls\"></a>\n<h3 translation-origin=\"off\" id=\"limited-function-calls\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#limited-function-calls\"><i class=\"material-icons\">link</i></a>Limited function calls</h3>\n<p translation-origin=\"off\">The <em>collector</em> can represent a function call or object creation with <code>new</code> as long as the syntax is valid. The <em>collector</em> only cares about proper syntax.</p>\n<p translation-origin=\"off\">But beware. The compiler may later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.\nThe compiler only supports calls to a small set of functions and will use <code>new</code> for only a few designated classes. These functions and classes are in a table of <a href=\"guide/aot-compiler#supported-functions\">below</a>.</p>\n<h3 translation-origin=\"off\" id=\"folding\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#folding\"><i class=\"material-icons\">link</i></a>Folding</h3>\n<a id=\"exported-symbols\"></a>\n<p translation-origin=\"off\">The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nFortunately, the <em>collector</em> enables limited use of non-exported symbols through <em>folding</em>.</p>\n<p translation-origin=\"off\">The <em>collector</em> may be able to evaluate an expression during collection and record the result in the <code>.metadata.json</code> instead of the original expression.</p>\n<p translation-origin=\"off\">For example, the <em>collector</em> can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.</p>\n<p translation-origin=\"off\">This process is called <em>folding</em>. An expression that can be reduced in this manner is <em>foldable</em>.</p>\n<a id=\"var-declaration\"></a>\n<p translation-origin=\"off\">The collector can evaluate references to\nmodule-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.json</code> file.</p>\n<p translation-origin=\"off\">Consider the following component definition:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">The compiler could not refer to the <code>template</code> constant because it isn't exported.</p>\n<p translation-origin=\"off\">But the <em>collector</em> can <em>fold</em> the <code>template</code> constant into the metadata definition by inlining its contents.\nThe effect is the same as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.json</code>.</p>\n<p translation-origin=\"off\">You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">The <em>collector</em> reduces this expression to its equivalent <em>folded</em> string:</p>\n<p translation-origin=\"off\"><code>'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'</code>.</p>\n<h4 translation-origin=\"off\" id=\"foldable-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a>Foldable syntax</h4>\n<p translation-origin=\"off\">The following table describes which expressions the <em>collector</em> can and cannot fold:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Foldable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Calls</td>\n<td>no</td>\n</tr>\n<tr>\n<td>New</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Property access</td>\n<td>yes, if target is foldable</td>\n</tr>\n<tr>\n<td>Array index</td>\n<td>yes, if target and index are foldable</td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td>yes, if it is a reference to a local</td>\n</tr>\n<tr>\n<td>A template with no substitutions</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>A template with substitutions</td>\n<td>yes, if the substitutions are foldable</td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td>yes, if operand is foldable</td>\n</tr>\n<tr>\n<td>Supported binary operator</td>\n<td>yes, if both left and right are foldable</td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td>yes, if condition is foldable</td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td>yes, if the expression is foldable</td>\n</tr>\n</tbody>\n</table>\n<p translation-origin=\"off\">If an expression is not foldable, the collector writes it to <code>.metadata.json</code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> for the compiler to resolve.</p>\n<h2 translation-origin=\"off\" id=\"phase-2-code-generation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a>Phase 2: code generation</h2>\n<p translation-origin=\"off\">The <em>collector</em> makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.json</code>. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</p>\n<p translation-origin=\"off\">It's the compiler's job to interpret the <code>.metadata.json</code> in the code generation phase.</p>\n<p translation-origin=\"off\">The compiler understands all syntax forms that the <em>collector</em> supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n<p translation-origin=\"off\">The compiler can only reference <em>exported symbols</em>.</p>\n<p translation-origin=\"off\">Decorated component class members must be public. You cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private or internal.</p>\n<p translation-origin=\"off\">Data bound properties must also be public.</p>\n<code-example language=\"typescript\">\n// BAD CODE - title is private\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<p translation-origin=\"off\">Most importantly, the compiler only generates code to create instances of certain classes, support certain decorators, and call certain functions from the following lists.</p>\n<h3 translation-origin=\"off\" id=\"new-instances\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#new-instances\"><i class=\"material-icons\">link</i></a>New instances</h3>\n<p translation-origin=\"off\">The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</p>\n<h3 translation-origin=\"off\" id=\"annotationsdecorators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotationsdecorators\"><i class=\"material-icons\">link</i></a>Annotations/Decorators</h3>\n<p translation-origin=\"off\">The compiler only supports metadata for these Angular decorators.</p>\n<table>\n<thead>\n<tr>\n<th>Decorator</th>\n<th>Module</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n</tbody>\n</table>\n<h3 translation-origin=\"off\" id=\"macro-functions-and-macro-static-methods\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#macro-functions-and-macro-static-methods\"><i class=\"material-icons\">link</i></a>Macro-functions and macro-static methods</h3>\n<p translation-origin=\"off\">The compiler also supports <em>macros</em> in the form of functions or static\nmethods that return an expression.</p>\n<p translation-origin=\"off\">For example, consider the following function:</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<p translation-origin=\"off\">You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n<p translation-origin=\"off\">You might use  <code>wrapInArray()</code> like this:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">The compiler treats this usage as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">The collector is simplistic in its determination of what qualifies as a macro\nfunction; it can only contain a single <code>return</code> statement.</p>\n<p translation-origin=\"off\">The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex <a href=\"guide/ngmodules\">NgModules</a>.</p>\n<a id=\"metadata-rewriting\"></a>\n<h3 translation-origin=\"off\" id=\"metadata-rewriting\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a>Metadata rewriting</h3>\n<p translation-origin=\"off\">The compiler treats object literals containing the fields <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>, and <code>data</code> specially. The compiler converts the expression initializing one of these fields into an exported variable, which replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value—it just needs to be able to generate a reference to the value.</p>\n<p translation-origin=\"off\">You might write something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.</p>\n<p translation-origin=\"off\">To allow this, the compiler automatically rewrites this to something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">This allows the compiler to generate a reference to <code>ɵ0</code> in the\nfactory without having to know what the value of <code>ɵ0</code> contains.</p>\n<p translation-origin=\"off\">The compiler does the rewriting during the emit of the <code>.js</code> file. This doesn't rewrite the <code>.d.ts</code> file, however, so TypeScript doesn't recognize it as being an export. Thus, it does not pollute the ES module's exported API.</p>\n<h2 translation-origin=\"off\" id=\"metadata-errors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-errors\"><i class=\"material-icons\">link</i></a>Metadata Errors</h2>\n<p translation-origin=\"off\">The following are metadata errors you may encounter, with explanations and suggested corrections.</p>\n<p translation-origin=\"off\"><a href=\"guide/aot-compiler#expression-form-not-supported\">Expression form not supported</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-local-symbol\">Reference to a local (non-exported) symbol</a><br>\n<a href=\"guide/aot-compiler#only-initialized-variables\">Only initialized variables and constants</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-class\">Reference to a non-exported class</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-function\">Reference to a non-exported function</a><br>\n<a href=\"guide/aot-compiler#function-calls-not-supported\">Function calls are not supported</a><br>\n<a href=\"guide/aot-compiler#destructured-variable-not-supported\">Destructured variable or constant not supported</a><br>\n<a href=\"guide/aot-compiler#could-not-resolve-type\">Could not resolve type</a><br>\n<a href=\"guide/aot-compiler#name-expected\">Name expected</a><br>\n<a href=\"guide/aot-compiler#unsupported-enum-member-name\">Unsupported enum member name</a><br>\n<a href=\"guide/aot-compiler#tagged-template-expressions-not-supported\">Tagged template expressions are not supported</a><br>\n<a href=\"guide/aot-compiler#symbol-reference-expected\">Symbol reference expected</a><br></p>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"expression-form-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-form-not-supported\"><i class=\"material-icons\">link</i></a>Expression form not supported</h3>\n<p translation-origin=\"off\">The compiler encountered an expression it didn't understand while evalutating Angular metadata.</p>\n<p translation-origin=\"off\">Language features outside of the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\ncan produce this error, as seen in the following example:</p>\n<code-example>\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p translation-origin=\"off\">You can use <code>typeof</code> and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.</p>\n<p translation-origin=\"off\">Avoid this error by sticking to the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-local-non-exported-symbol\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-local-non-exported-symbol\"><i class=\"material-icons\">link</i></a>Reference to a local (non-exported) symbol</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.</p>\n<p translation-origin=\"off\">Here's a <code>provider</code> example of the problem.</p>\n<code-example>\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler generates the component factory, which includes the <code>useValue</code> provider code, in a separate module. <em>That</em> factory module can't reach back to <em>this</em> source module to access the local (non-exported) <code>foo</code> variable.</p>\n<p translation-origin=\"off\">You could fix the problem by initializing <code>foo</code>.</p>\n<code-example>\nlet foo = 42; // initialized\n</code-example>\n<p translation-origin=\"off\">The compiler will <a href=\"guide/aot-compiler#folding\">fold</a> the expression into the provider as if you had written this.</p>\n<code-example>\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p translation-origin=\"off\">Alternatively, you can fix it by exporting <code>foo</code> with the expectation that <code>foo</code> will be assigned at runtime when you actually know its value.</p>\n<code-example>\n// CORRECTED\nexport let foo: number; // exported\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">Adding <code>export</code> often works for variables referenced in metadata such as <code>providers</code> and <code>animations</code> because the compiler can generate <em>references</em> to the exported variables in these expressions. It doesn't need the <em>values</em> of those variables.</p>\n<p translation-origin=\"off\">Adding <code>export</code> doesn't work when the compiler needs the <em>actual value</em>\nin order to generate code.\nFor example, it doesn't work for the <code>template</code> property.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler needs the value of the <code>template</code> property <em>right now</em> to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with <code>export</code> merely produces a new error, \"<a href=\"guide/aot-compiler#only-initialized-variables\"><code>Only initialized variables and constants can be referenced</code></a>\".</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"only-initialized-variables-and-constants\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#only-initialized-variables-and-constants\"><i class=\"material-icons\">link</i></a>Only initialized variables and constants</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.</p>\n<p translation-origin=\"off\">The following example tries to set the component's <code>template</code> property to the value of\nthe exported <code>someTemplate</code> variable which is declared but <em>unassigned</em>.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">You'd also get this error if you imported <code>someTemplate</code> from some other module and neglected to initialize it there.</p>\n<code-example>\n// ERROR - not initialized there either\nimport { someTemplate } from './config';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the <code>someTemplate</code> variable from the source code\nso that it can generate the component factory, which includes\ninstructions for building the element based on the template.</p>\n<p translation-origin=\"off\">To correct this error, provide the initial value of the variable in an initializer clause <em>on the same line</em>.</p>\n<code-example>\n// CORRECTED\nexport let someTemplate = '&#x3C;h1>Greetings from Angular&#x3C;/h1>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-non-exported-class\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-class\"><i class=\"material-icons\">link</i></a>Reference to a non-exported class</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Reference to a non-exported class <class name=\"\">. Consider exporting the class.</class></em></p>\n</div>\n<p translation-origin=\"off\">Metadata referenced a class that wasn't exported.</p>\n<p translation-origin=\"off\">For example, you may have defined a class and used it as an injection token in a providers array\nbut neglected to export that class.</p>\n<code-example>\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported classes</a>.\nTo correct this error, export the referenced class.</p>\n<code-example>\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-non-exported-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-function\"><i class=\"material-icons\">link</i></a>Reference to a non-exported function</h3>\n<p translation-origin=\"off\">Metadata referenced a function that wasn't exported.</p>\n<p translation-origin=\"off\">For example, you may have set a providers <code>useFactory</code> property to a locally defined function that you neglected to export.</p>\n<code-example>\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported functions</a>.\nTo correct this error, export the function.</p>\n<code-example>\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"function-calls-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#function-calls-are-not-supported\"><i class=\"material-icons\">link</i></a>Function calls are not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler does not currently support <a href=\"guide/aot-compiler#function-expression\">function expressions or lambda functions</a>.\nFor example, you cannot set a provider's <code>useFactory</code> to an anonymous function or arrow function like this.</p>\n<code-example>\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">You also get this error if you call a function or method in a provider's <code>useValue</code>.</p>\n<code-example>\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">To correct this error, export a function from the module and refer to the function in a <code>useFactory</code> provider instead.</p>\n<code-example linenums=\"false\">\n\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"destructured-variable-or-constant-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#destructured-variable-or-constant-not-supported\"><i class=\"material-icons\">link</i></a>Destructured variable or constant not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler does not support references to variables assigned by <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">destructuring</a>.</p>\n<p translation-origin=\"off\">For example, you cannot write something like this:</p>\n<code-example linenums=\"false\">\n\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n\n</code-example>\n<p translation-origin=\"off\">To correct this error, refer to non-destructured values.</p>\n<code-example linenums=\"false\">\n\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"could-not-resolve-type\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#could-not-resolve-type\"><i class=\"material-icons\">link</i></a>Could not resolve type</h3>\n<p translation-origin=\"off\">The compiler encountered a type and can't determine which module exports that type.</p>\n<p translation-origin=\"off\">This can happen if you refer to an ambient type.\nFor example, the <code>Window</code> type is an ambiant type declared in the global <code>.d.ts</code> file.</p>\n<p translation-origin=\"off\">You'll get an error if you reference it in the component constructor,\nwhich the compiler must statically analyze.</p>\n<code-example>\n// ERROR\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p translation-origin=\"off\">TypeScript understands ambiant types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.</p>\n<p translation-origin=\"off\">In this case, the compiler doesn't understand how to inject something with the <code>Window</code> token.</p>\n<p translation-origin=\"off\">Do not refer to ambient types in metadata expressions.</p>\n<p translation-origin=\"off\">If you must inject an instance of an ambiant type,\nyou can finesse the problem in four steps:</p>\n<ol>\n<li>\n<p translation-origin=\"off\">Create an injection token for an instance of the ambiant type.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Create a factory function that returns that instance.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Add a <code>useFactory</code> provider with that factory function.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Use <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> to inject the instance.</p>\n</li>\n</ol>\n<p translation-origin=\"off\">Here's an illustrative example.</p>\n<code-example linenums=\"false\">\n\n// CORRECTED\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n\n</code-example>\n<p translation-origin=\"off\">The <code>Window</code> type in the constructor is no longer a problem for the compiler because it\nuses the <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code> to generate the injection code.</p>\n<p translation-origin=\"off\">Angular does something similar with the <code>DOCUMENT</code> token so you can inject the browser's <code>document</code> object (or an abstraction of it, depending upon the platform in which the application runs).</p>\n<code-example linenums=\"false\">\n\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-browser';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(DOCUMENT) private doc: Document) { ... }\n}\n\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"name-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#name-expected\"><i class=\"material-icons\">link</i></a>Name expected</h3>\n<p translation-origin=\"off\">The compiler expected a name in an expression it was evaluating.\nThis can happen if you use a number as a property name as in the following example.</p>\n<code-example>\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p translation-origin=\"off\">Change the name of the property to something non-numeric.</p>\n<code-example>\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"unsupported-enum-member-name\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#unsupported-enum-member-name\"><i class=\"material-icons\">link</i></a>Unsupported enum member name</h3>\n<p translation-origin=\"off\">Angular couldn't determine the value of the <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">enum member</a>\nthat you referenced in metadata.</p>\n<p translation-origin=\"off\">The compiler can understand simple enum values but not complex values such as those derived from computed properties.</p>\n<code-example linenums=\"false\">\n\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n\n</code-example>\n<p translation-origin=\"off\">Avoid referring to enums with complicated initializers or computed properties.</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"tagged-template-expressions-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#tagged-template-expressions-are-not-supported\"><i class=\"material-icons\">link</i></a>Tagged template expressions are not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Tagged template expressions are not supported in metadata.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler encountered a JavaScript ES2015 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">tagged template expression</a> such as,</p>\n<code-example>\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '&#x3C;div>' + raw + '&#x3C;/div>'\n ...\n</code-example>\n<p translation-origin=\"off\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a>\nis a <em>tag function</em> native to JavaScript ES2015.</p>\n<p translation-origin=\"off\">The AOT compiler does not support tagged template expressions; avoid them in metadata expressions.</p>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"symbol-reference-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#symbol-reference-expected\"><i class=\"material-icons\">link</i></a>Symbol reference expected</h3>\n<p translation-origin=\"off\">The compiler expected a reference to a symbol at the location specified in the error message.</p>\n<p translation-origin=\"off\">This error can occur if you use an expression in the <code>extends</code> clause of a class.</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n<a id=\"binding-expresion-validation\"></a>\n<h2 translation-origin=\"off\" id=\"phase-3-binding-expression-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-binding-expression-validation\"><i class=\"material-icons\">link</i></a>Phase 3: binding expression validation</h2>\n<p translation-origin=\"off\">  In the validation phase, the Angular template compiler uses the TypeScript compiler to validate the\nbinding expressions in templates. Enable this phase explicity by adding the compiler\noption <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's <code>tsconfig.json</code> (see\n<a href=\"guide/aot-compiler#compiler-options\">Angular Compiler Options</a>).</p>\n<p translation-origin=\"off\">  Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n<p translation-origin=\"off\">  For example, consider the following component:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p translation-origin=\"off\">  This will produce the following error:</p>\n<code-example>\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<p translation-origin=\"off\">  The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nCompiler never writes this file to disk. The line and column numbers are relative to the template string\nin the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case. If a component uses\n<code>templateUrl</code> instead of <code>template</code>, the errors are reported in the HTML file refereneced by the\n<code>templateUrl</code> instead of a synthetic file.</p>\n<p translation-origin=\"off\">  The error location is the beginning of the text node that contains the interpolation expression with\nthe error. If the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n<p translation-origin=\"off\">  The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control\nhow detailed the type validation is. For example, if the <code>strictTypeChecks</code> is specified, the error  <code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code> is reported as well as the above error message.</p>\n<h3 translation-origin=\"off\" id=\"type-narrowing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a>Type narrowing</h3>\n<p translation-origin=\"off\">  The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript. For example, to avoid\n<code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the\ninterpolation if the value of <code>person</code> is initialized as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.addresss.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p translation-origin=\"off\">  Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the\nbinding expression will never be <code>undefined</code>.</p>\n<h4 translation-origin=\"off\" id=\"custom-ngif-like-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#custom-ngif-like-directives\"><i class=\"material-icons\">link</i></a>Custom <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> like directives</h4>\n<p translation-origin=\"off\">  Directives that behave like <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> can declare that they want the same treatment by including\na static member marker that is a signal to the template compiler to treat them\nlike <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>. This static member for <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is:</p>\n<code-example language=\"typescript\">\n  public <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngIfUseIfTypeGuard: void;\n</code-example>\n<p translation-origin=\"off\">  This declares that the input property <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> of the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive should be treated as a\nguard to the use of its template, implying that the template will only be instantiated if\nthe <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> input property is true.</p>\n<h3 translation-origin=\"off\" id=\"non-null-type-assertion-operator\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a>Non-null type assertion operator</h3>\n<p translation-origin=\"off\">  Use the <a href=\"guide/template-syntax#non-null-assertion-operator\">non-null type assertion operator</a>\nto suppress the <code>Object is possibly 'undefined'</code> error when it is incovienent to use\n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always\nnon-null when the binding expression is interpolated.</p>\n<p translation-origin=\"off\">  In the following example, the <code>person</code> and <code>address</code> properties are always set together,\nimplying that <code>address</code> is always non-null if <code>person</code> is non-null. There is no convenient\nway to describe this constraint to TypeScript and the template compiler, but the error\nis suppressed in the example by using <code>address!.street</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<p translation-origin=\"off\">  The non-null assertion operator should be used sparingly as refactoring of the component\nmight break this constraint.</p>\n<p translation-origin=\"off\">  In this example it is recommended to include the checking of <code>address</code>\nin the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<h3 translation-origin=\"off\" id=\"disabling-type-checking-using-any\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a>Disabling type checking using <code>$any()</code></h3>\n<p translation-origin=\"off\">  Disable checking of a binding expression by surrounding the expression\nin a call to the <a href=\"guide/template-syntax\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&#x3C;any></code>\nor <code>as any</code> cast is used.</p>\n<p translation-origin=\"off\">  In the following example, the error <code>Property addresss does not exist</code> is suppressed\nby casting <code>person</code> to the <code>any</code> type.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<h2 translation-origin=\"off\" id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<h2 translation-result=\"\" id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#summary\"><i class=\"material-icons\">link</i></a>小结</h2>\n<ul>\n<li>\n<p translation-origin=\"off\">What the AOT compiler does and why it is important.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Why metadata must be written in a subset of JavaScript.</p>\n</li>\n<li>\n<p translation-origin=\"off\">What that subset is.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Other restrictions on metadata definition.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Macro-functions and macro-static methods.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Compiler errors related to metadata.</p>\n</li>\n<li>\n<p translation-origin=\"off\">Validation of binding expressions</p>\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/browser-support\n - guide/change-log\n - guide/deployment\n - guide/npm-packages\n - guide/quickstart\n - guide/universal\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Attribute\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/Host\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ViewChild\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/upgrade/static\n - guide/aot-compiler#allowemptycodegenfiles\n - guide/aot-compiler#angular-compilation\n - guide/aot-compiler#angular-compiler-options\n - guide/aot-compiler#angular-metadata-and-aot\n - guide/aot-compiler#annotateforclosurecompiler\n - guide/aot-compiler#annotationsas\n - guide/aot-compiler#annotationsdecorators\n - guide/aot-compiler#binding-expresion-validation\n - guide/aot-compiler#compiler-options\n - guide/aot-compiler#could-not-resolve-type\n - guide/aot-compiler#custom-ngif-like-directives\n - guide/aot-compiler#destructured-variable-not-supported\n - guide/aot-compiler#destructured-variable-or-constant-not-supported\n - guide/aot-compiler#disableexpressionlowering\n - guide/aot-compiler#disabling-type-checking-using-any\n - guide/aot-compiler#enableivy\n - guide/aot-compiler#enablelegacytemplate\n - guide/aot-compiler#exported-symbols\n - guide/aot-compiler#expression-form-not-supported\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#flatmoduleid\n - guide/aot-compiler#flatmoduleoutfile\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#folding\n - guide/aot-compiler#fulltemplatetypecheck\n - guide/aot-compiler#function-calls-are-not-supported\n - guide/aot-compiler#function-calls-not-supported\n - guide/aot-compiler#function-expression\n - guide/aot-compiler#generatecodeforlibraries\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#limited-function-calls\n - guide/aot-compiler#macro-functions-and-macro-static-methods\n - guide/aot-compiler#metadata-errors\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#name-expected\n - guide/aot-compiler#new-instances\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#only-initialized-variables\n - guide/aot-compiler#only-initialized-variables-and-constants\n - guide/aot-compiler#phase-1-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-binding-expression-validation\n - guide/aot-compiler#preservewhitespaces\n - guide/aot-compiler#reference-to-a-local-non-exported-symbol\n - guide/aot-compiler#reference-to-a-local-symbol\n - guide/aot-compiler#reference-to-a-non-exported-class\n - guide/aot-compiler#reference-to-a-non-exported-function\n - guide/aot-compiler#skipmetadataemit\n - guide/aot-compiler#skiptemplatecodegen\n - guide/aot-compiler#strictinjectionparameters\n - guide/aot-compiler#strictmetadataemit\n - guide/aot-compiler#summary\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#symbol-reference-expected\n - guide/aot-compiler#tagged-template-expressions-are-not-supported\n - guide/aot-compiler#tagged-template-expressions-not-supported\n - guide/aot-compiler#the-ahead-of-time-aot-compiler\n - guide/aot-compiler#trace\n - guide/aot-compiler#type-narrowing\n - guide/aot-compiler#unsupported-enum-member-name\n - guide/aot-compiler#why-compile-with-aot\n - guide/ngmodules\n - guide/template-syntax\n - guide/template-syntax#non-null-assertion-operator\n - http://usejsdoc.org/\n - http://v.youku.com/v_show/id_XMTc1NTE4NTkwOA==.html?from=y1.7-1.4\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular-cli/wiki\n - https://github.com/angular/angular-cli/wiki/build\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/tsickle\n - https://github.com/google/closure-compiler\n - https://webpack.js.org/\n - https://www.typescriptlang.org/docs/handbook/enums.html\n - https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\n - https://www.youtube.com/watch?v=kW9cJsvcsGo\n-->"
}