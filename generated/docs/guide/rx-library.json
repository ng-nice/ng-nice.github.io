{
  "id": "guide/rx-library",
  "title": "The RxJS library",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"the-rxjs-library\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a>The RxJS library</h1>\n<p translation-origin=\"off\">Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code (<a href=\"http://reactivex.io/rxjs/\">RxJS Docs</a>).</p>\n<p translation-origin=\"off\">RxJS provides an implementation of the <code>Observable</code> type, which is needed until the type becomes part of the language and until browsers support it. The library also provides utility functions for creating and working with observables. These utility functions can be used for:</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Converting existing code for async operations into observables</p>\n</li>\n<li>\n<p translation-origin=\"off\">Iterating through the values in a stream</p>\n</li>\n<li>\n<p translation-origin=\"off\">Mapping values to different types</p>\n</li>\n<li>\n<p translation-origin=\"off\">Filtering streams</p>\n</li>\n<li>\n<p translation-origin=\"off\">Composing multiple streams</p>\n</li>\n</ul>\n<h2 translation-origin=\"off\" id=\"observable-creation-functions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a>Observable creation functions</h2>\n<p translation-origin=\"off\">RxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, promises, and so on. For example:</p>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" title=\"Create an observable from a promise\">\n\nimport { fromPromise } from 'rxjs/observable/fromPromise';\n\n// Create an Observable out of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> promise\nconst data = fromPromise(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n next(response) { console.log(response); },\n error(err) { console.error('Error: ' + err); },\n complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" title=\"Create an observable from a counter\">\n\nimport { interval } from 'rxjs/observable/interval';\n\n// Create an Observable that will publish <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nsecondsCounter.subscribe(n =>\n  console.log(`It's been ${n} seconds since subscribing!`));\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" title=\"Create an observable from an event\">\n\nimport { fromEvent } from 'rxjs/observable/fromEvent';\n\nconst el = document.getElementById('my-element');\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe((evt: MouseEvent) => {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &#x3C; 40 &#x26;&#x26; evt.clientY &#x3C; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" title=\"Create an observable that creates an AJAX request\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res => console.log(res.status, res.response));\n\n\n</code-example>\n<h2 translation-origin=\"off\" id=\"operators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a>Operators</h2>\n<p translation-origin=\"off\">Operators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as <code>map()</code>, <code>filter()</code>, <code>concat()</code>, and <code>flatMap()</code>.</p>\n<p translation-origin=\"off\">Operators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable’s emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:</p>\n<code-example path=\"rx-library/src/operators.ts\" title=\"Map operator\">\n\nimport { map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3);\n\nconst squareValues = map((val: number) => val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x => console.log(x));\n\n// Logs\n// 1\n// 4\n// 9\n\n\n</code-example>\n<p translation-origin=\"off\">You can use <em>pipes</em> to link operators together. Pipes let you combine multiple functions into a single function. The <code>pipe()</code> function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.</p>\n<p translation-origin=\"off\">A set of operators applied to an observable is a recipe—that is, a set of instructions for producing the values you’re interested in. By itself, the recipe doesn’t do anything. You need to call <code>subscribe()</code> to produce a result through the recipe.</p>\n<p translation-origin=\"off\">Here’s an example:</p>\n<code-example path=\"rx-library/src/operators.1.ts\" title=\"Standalone pipe function\">\n\nimport { pipe } from 'rxjs/util/pipe';\nimport { filter, map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3, 4, 5);\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter(n => n % 2),\n  map(n => n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Suscribe to run the combined functions\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<p translation-origin=\"off\">The <code>pipe()</code> function is also a method on the RxJS <code>Observable</code>, so you use this shorter form to define the same operation:</p>\n<code-example path=\"rx-library/src/operators.2.ts\" title=\"Observable.pipe function\">\n\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\n\nconst squareOdd = Observable.of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n => n % 2),\n    map(n => n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"common-operators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a>Common operators</h3>\n<p translation-origin=\"off\">RxJS provides many operators (over 150 of them), but only a handful are used frequently. Here is a list of common operators; for usage examples, see  <a href=\"https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\">RxJS 5 Operators By Example</a> in RxJS documentation.</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">  Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.</p>\n</div>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Area</th>\n<th align=\"left\">Operators</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Creation</td>\n<td align=\"left\"><code>from</code>\n, \n<code>fromPromise</code>\n,\n<code>fromEvent</code>\n, \n<code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\">Combination</td>\n<td align=\"left\"><code>combineLatest</code>\n, \n<code>concat</code>\n, \n<code>merge</code>\n, \n<code>startWith</code>\n , \n<code>withLatestFrom</code>\n, \n<code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\">Filtering</td>\n<td align=\"left\"><code>debounceTime</code>\n, \n<code>distinctUntilChanged</code>\n, \n<code>filter</code>\n, \n<code>take</code>\n, \n<code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\">Transformation</td>\n<td align=\"left\"><code>bufferTime</code>\n, \n<code>concatMap</code>\n, \n<code>map</code>\n, \n<code>mergeMap</code>\n, \n<code>scan</code>\n, \n<code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Utility</td>\n<td align=\"left\"><code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\">Multicasting</td>\n<td align=\"left\"><code>share</code></td>\n</tr>\n</tbody>\n</table>\n<h2 translation-origin=\"off\" id=\"error-handling\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a>Error handling</h2>\n<h2 translation-result=\"\" id=\"error-handling-3\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling-3\"><i class=\"material-icons\">link</i></a>错误处理</h2>\n<p translation-origin=\"off\">In addition to the <code>error()</code> handler that you provide on subscription, RxJS provides the <code>catchError</code> operator that lets you handle known errors in the observable recipe.</p>\n<p translation-origin=\"off\">For instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn’t exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.</p>\n<p translation-origin=\"off\">Here's an example of using the <code>catchError</code> operator to do this:</p>\n<code-example path=\"rx-library/src/error-handling.ts\" title=\"catchError operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, catchError } from 'rxjs/operators';\n// Return \"response\" from the API. If an error happens,\n// return an empty array.\nconst apiData = ajax('/api/data').pipe(\n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"retry-failed-observable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a>Retry failed observable</h3>\n<p translation-origin=\"off\">Where the <code>catchError</code> operator provides a simple path of recovery, the <code>retry</code> operator lets you retry a failed request.</p>\n<p translation-origin=\"off\">Use the <code>retry</code> operator before the <code>catchError</code> operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.</p>\n<p translation-origin=\"off\">The following converts the previous example to retry the request before catching the error:</p>\n<code-example path=\"rx-library/src/retry-on-error.ts\" title=\"retry operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  retry(3), // Retry up to 3 times before failing\n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">   Do not retry <strong>authentication</strong> requests, since these should only be initiated by user action. We don't want to lock out user accounts with repeated login requests that the user has not initiated.</p>\n</div>\n<h2 translation-origin=\"off\" id=\"naming-conventions-for-observables\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a>Naming conventions for observables</h2>\n<p translation-origin=\"off\">Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing “$” sign.</p>\n<p translation-origin=\"off\">This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the “$”.</p>\n<p translation-origin=\"off\">For example:</p>\n<p translation-result=\"\">比如：</p>\n<code-example path=\"rx-library/src/naming-convention.ts\" title=\"Naming observables\">\n\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-stopwatch',\n  templateUrl: './stopwatch.component.html'\n})\nexport class StopwatchComponent {\n\n  stopwatchValue: number;\n  stopwatchValue$: Observable&#x3C;number>;\n\n  start() {\n    this.stopwatchValue$.subscribe(num =>\n      this.stopwatchValue = num\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/async\n - api/router/RouterLinkWithHref\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#error-handling-3\n - guide/rx-library#naming-conventions-for-observables\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#the-rxjs-library\n - http://reactivex.io/rxjs/\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\n-->"
}